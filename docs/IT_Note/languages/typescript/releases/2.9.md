---
description: TypeScript2.9のリリース内容まとめ
---

# [TypeScript] 2.9

{{ page.meta.description }}


## [Support number and symbol named properties with keyof and mapped types]

[Support number and symbol named properties with keyof and mapped types]: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types

{{label('had_better')}} {{label('normal')}}

index typesや[mapped types]で`number`や`symbol`のnamed propertiesをサポートするようになった。

| バージョン | named propertiesでサポートする型 |
| ---------- | -------------------------------- |
| 2.8以前    | string                           |
| 2.9        | string, **number**, **symbol**   |

=== "index typesがstring"
    ```typescript
    const One = Symbol();
    interface A {
      one: string;
      1: string;
      [One]: string;
      [x: string]: string;
    }
    type KeyOfA = keyof A;
    // v2.8: string
    //   * 1はstringとして扱われるため "one" | "1"
    //   * symbolは未対応なので無視
    //   * stringのindex typesに "one" | "1" も含まれるのでまとめてstring
    // v2.9: string | number | unique symbol
    //   * keyofがnumberとsymbolをサポートするようになった
    //   * "one"はstringのサブタイプとして統合された
    ```

=== "index typesがnumber"
    ```typescript
    const Two = Symbol();
    interface B {
      two: string;
      2: string;
      [Two]: string;
      [x: number]: string;
    }
    type KeyOfB = keyof B;
    // v2.8: "two" | "2"
    //   * 2はstringとして扱われるため "two" | "2"
    //   * symbolは未対応なので無視
    //   * numberのindex typesはサポート外のため無視
    // v2.9: number | unique symbol | "two"
    //   * keyofがnumberとsymbolをサポートするようになった
    //   * 2はnumberのサブタイプとして統合されたが、"two"と[Two]はnumberでないため残る
    ```

=== "index typesなし"
    ```typescript
    const Three = Symbol();
    interface C {
      three: string;
      3: string;
      [Three]: string;
    }
    type KeyOfC = keyof C;
    // v2.8: "three" | "3"
    //   * 3はstringとして扱われるため "three" | "3"
    //   * symbolは未対応なので無視
    // v2.9: unique symbol | "three" | 3
    //   * index typesは無いので、named propertiesがそのままunion typesとして適応される
    ```

index typesがstring以外の場合で[mapped types]を用いても、index typesの型が尊重される。

```typescript
interface D {
  hoge: string;
  [x: number]: string;
}
type ReadonlyType<T> = { readonly [P in keyof D]: D[P] };
declare const tmp: ReadonlyType<D>;
const r = tmp[10];
// v2.8: TS7017: Element implicitly has an 'any' type because type 'ReadonlyType ' has no index signature
//   * numberのindex typesは未対応のため認識されないからanyになる
// v2.9: rはstring
//   * numberのindex typesが認識されるためstringとみなされる
```

!!! warning "JetBrainsのIDEで型推論が上手く反映されない"
    稀に、IDE特有の機能を使って判定された型は正しく推論されないことがあります。  
    その場合はtscの実行結果を確認して、そちらを信じましょう😜

[mapped types]: ../2.1/#mapped-types
