---
description: TypeScript2.9のリリース内容まとめ
---

# [TypeScript] 2.9

{{ page.meta.description }}


## [Support number and symbol named properties with keyof and mapped types]

[Support number and symbol named properties with keyof and mapped types]: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types

{{label('had_better')}} {{label('normal')}}

index typesや[mapped types]で`number`や`symbol`のnamed propertiesをサポートするようになった。

| バージョン | named propertiesでサポートする型 |
| ---------- | -------------------------------- |
| 2.8以前    | string                           |
| 2.9        | string, **number**, **symbol**   |

=== "index typesがstring"
    ```typescript
    const One = Symbol();
    interface A {
      one: string;
      1: string;
      [One]: string;
      [x: string]: string;
    }
    type KeyOfA = keyof A;
    // v2.8: string
    //   * 1はstringとして扱われるため "one" | "1"
    //   * symbolは未対応なので無視
    //   * stringのindex typesに "one" | "1" も含まれるのでまとめてstring
    // v2.9: string | number | unique symbol
    //   * keyofがnumberとsymbolをサポートするようになった
    //   * "one"はstringのサブタイプとして統合された
    ```

=== "index typesがnumber"
    ```typescript
    const Two = Symbol();
    interface B {
      two: string;
      2: string;
      [Two]: string;
      [x: number]: string;
    }
    type KeyOfB = keyof B;
    // v2.8: "two" | "2"
    //   * 2はstringとして扱われるため "two" | "2"
    //   * symbolは未対応なので無視
    //   * numberのindex typesはサポート外のため無視
    // v2.9: number | unique symbol | "two"
    //   * keyofがnumberとsymbolをサポートするようになった
    //   * 2はnumberのサブタイプとして統合されたが、"two"と[Two]はnumberでないため残る
    ```

=== "index typesなし"
    ```typescript
    const Three = Symbol();
    interface C {
      three: string;
      3: string;
      [Three]: string;
    }
    type KeyOfC = keyof C;
    // v2.8: "three" | "3"
    //   * 3はstringとして扱われるため "three" | "3"
    //   * symbolは未対応なので無視
    // v2.9: unique symbol | "three" | 3
    //   * index typesは無いので、named propertiesがそのままunion typesとして適応される
    ```

index typesがstring以外の場合で[mapped types]を用いても、index typesの型が尊重される。

```typescript
interface D {
  hoge: string;
  [x: number]: string;
}
type ReadonlyType<T> = { readonly [P in keyof D]: D[P] };
declare const tmp: ReadonlyType<D>;
const r = tmp[10];
// v2.8: TS7017: Element implicitly has an 'any' type because type 'ReadonlyType ' has no index signature
//   * numberのindex typesは未対応のため認識されないからanyになる
// v2.9: rはstring
//   * numberのindex typesが認識されるためstringとみなされる
```

!!! warning "JetBrainsのIDEで型推論が上手く反映されない"
    稀に、IDE特有の機能を使って判定された型は正しく推論されないことがあります。  
    その場合はtscの実行結果を確認して、そちらを信じましょう😜


## [Generic type arguments in JSX elements]

[Generic type arguments in JSX elements]: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#generic-type-arguments-in-jsx-elements

{{label('had_better')}} {{label('easy')}}

JSX要素にジェネリクスの型引数を渡せるようになった。  
`<YourComponent<Props> />`のような感じ。


## [Generic type arguments in generic tagged templates]

[Generic type arguments in generic tagged templates]: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#generic-type-arguments-in-generic-tagged-templates

{{label('had_better')}} {{label('easy')}}

タグ付けテンプレートにジェネリクスが使えるようになった。

```typescript
export function twice<T>(strs: TemplateStringsArray, ...values: T[]): string {
  return strs.reduce(
    (accum, str, i) => `${accum}${values[i - 1]}${values[i - 1]}${str}`
  );
}

const res1 = twice<string>`I play ${"tennis"} every ${"day"}`;
const res2 = twice<number>`I play ${1} every ${200}`;

console.log(res1);
// -> I play tennistennis every dayday
console.log(res2);
// -> I play 11 every 200200
```


## [import types]

[import types]: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#import-types

{{label('unknown')}} {{label('easy')}}

型注釈でimportタイプが使えるようになった。

`sub.ts`
```typescript
export declare class Human {
  id: number;
  name: string;
}
```

`main.ts`
```typescript
function getName(human: import("./sub").Human): string {
  return human.name;
}
```

!!! question "どういうとき使うのかが分からない.."
    非モジュールファイルからも宣言のみのクラスをimportできたので..

[mapped types]: ../2.1/#mapped-types
