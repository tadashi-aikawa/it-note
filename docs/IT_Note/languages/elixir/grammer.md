# [Elixir] Grammer


以下を参考にメモ。

{{link("https://elixirschool.com/ja/")}}


基本
----

### アトム

自身の名前が値になる定数。

```elixir
iex> :foo
:foo
```

`true`/`false`の実体はアトムの`:true`/`:false`。

### 文字列

* *UTF-8エンコードされた符合* (Unicodeではない)
* ダブルクォート
* 式展開は`#{変数名}`
* 連結は`<>`

### 割り算

* 常に浮動小数点を返す
* 整数同士の割り算や剰余は`div()`、`rem()`を使う

### 論理

`&&`や`||`、`!`について  
0、空文字、空配列は全てtrue。

真理値(bool)の後には`and`/`or`/`not`が使える。

### 比較

* `===`は厳密等価判定
* 異なる型同士の比較ができる
  * `number < atom < reference < function < port < pid < tuple < map < list < bitstring`


コレクション
------------

### リスト

* 複数の型を含むことができる `[1, "one", :one]`
* 連結リスト
  * 長さ取得に弱い
  * 要素の追加は先頭の方が良い `["hoge" | list]`
  * 末尾へ追加の場合は`++/2`を使う
* 減算は`--/2`

関数は`function_name/arity`で表現。arityは引数の数。

| 関数名 |        説明        |      例      |  結果  |
| ------ | ------------------ | ------------ | ------ |
| hd     | 先頭を取り出す     | hd [1, 2, 3] | 1      |
| tl     | 先頭以外を取り出す | tl [1, 2, 3] | [2, 3] |

### タプル

* メモリ上に隣接して格納される
  * 長さの取得に強い
  * 修正は遅い
* 分割代入/パターンマッチでよく使う

### キーワードリスト

* `[id: 1, name: "tadashi"]`
  * 上記は`[{:id, 1}, {:name, "tadashi"}]`と等価
* キーはアトム
* キーは順序付けされる
* *キーは一意とは限らない*

あくまでリスト。

### マップ

* `%{:id => 1, "name" => "tadashi"}`
  * `%`ではじまる
  * キーはどんな型でも使える. 変数もOK.
  * `=>`で値を指す
  * `map[key]`で要素を取得
* キーがアトムだけであればJavaScriptに近い書き方ができる
  * `%{id: 1, name: "tadashi"}`
  * `map.key`で要素を取得
* `|`で新しいmapのassignができる
  * `%{map | id: 100}`
  * 新しいキーの追加はできない.. `Map.put/3`を使う
    * `Map.put(map, :hoge, "hoga")`

Enum
----

関数型チックな処理です。

* デフォルトは即時処理
  * 遅延処理の場合はStreamモジュールを使う


|   関数名    |            説明            |                例                |       結果        |
| ----------- | -------------------------- | -------------------------------- | ----------------- |
| all?        | 全てがtrueならtrue         | Enum.all?([0, true, :true])      | true              |
| any?        | 1つでもtrueならtrue        | Enum.any?([0, true, :false])     | true              |
| chunk_every | 特定サイズの配列に分割する | Enum.chunk_every([1,2,3,4,5], 2) | [[1,2],[3,4],[5]] |


ラムダ式
--------

`fn (el1, el2) -> el1 * el2 end`と`&(&1 * &2)`は等価
