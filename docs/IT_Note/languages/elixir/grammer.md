# [Elixir] Grammer


以下を参考にメモ。

{{link("https://elixirschool.com/ja/")}}


基本
----

### アトム

自身の名前が値になる定数。

```elixir
iex> :foo
:foo
```

`true`/`false`の実体はアトムの`:true`/`:false`。

### 文字列

* *UTF-8エンコードされた符合* (Unicodeではない)
* ダブルクォート
* 式展開は`#{変数名}`
* 連結は`<>`

### 割り算

* 常に浮動小数点を返す
* 整数同士の割り算や剰余は`div()`、`rem()`を使う

### 論理

`&&`や`||`、`!`について  
0、空文字、空配列は全てtrue。

真理値(bool)の後には`and`/`or`/`not`が使える。

### 比較

* `===`は厳密等価判定
* 異なる型同士の比較ができる
  * `number < atom < reference < function < port < pid < tuple < map < list < bitstring`


コレクション
------------

### リスト

* 複数の型を含むことができる `[1, "one", :one]`
* 連結リスト
  * 長さ取得に弱い
  * 要素の追加は先頭の方が良い `["hoge" | list]`
  * 末尾へ追加の場合は`++/2`を使う
* 減算は`--/2`

関数は`function_name/arity`で表現。arityは引数の数。

| 関数名 |        説明        |      例      |  結果  |
| ------ | ------------------ | ------------ | ------ |
| hd     | 先頭を取り出す     | hd [1, 2, 3] | 1      |
| tl     | 先頭以外を取り出す | tl [1, 2, 3] | [2, 3] |

### タプル

* メモリ上に隣接して格納される
  * 長さの取得に強い
  * 修正は遅い
* 分割代入/パターンマッチでよく使う

### キーワードリスト

* `[id: 1, name: "tadashi"]`
  * 上記は`[{:id, 1}, {:name, "tadashi"}]`と等価
* キーはアトム
* キーは順序付けされる
* *キーは一意とは限らない*

あくまでリスト。

### マップ

* `%{:id => 1, "name" => "tadashi"}`
  * `%`ではじまる
  * キーはどんな型でも使える. 変数もOK.
  * `=>`で値を指す
  * `map[key]`で要素を取得
* キーがアトムだけであればJavaScriptに近い書き方ができる
  * `%{id: 1, name: "tadashi"}`
  * `map.key`で要素を取得
* `|`で新しいmapのassignができる
  * `%{map | id: 100}`
  * 新しいキーの追加はできない.. `Map.put/3`を使う
    * `Map.put(map, :hoge, "hoga")`

Enum
----

関数型チックな処理です。

* デフォルトは即時処理
  * 遅延処理の場合はStreamモジュールを使う


|   関数名    |                説明                |                           例                           |        結果         |
| ----------- | ---------------------------------- | ------------------------------------------------------ | ------------------- |
| all?        | 全てがtrueならtrue                 | Enum.all? [0, true, :true]                             | true                |
| any?        | 1つでもtrueならtrue                | Enum.any? [0, true, :false]                            | true                |
| chunk_every | 特定サイズの配列に分割する         | Enum.chunk_every 1..5, 2                               | [[1,2],[3,4],[5]]   |
| chunk_by    | 関数の結果が同じもの同士で分割する |                                                        |                     |
| map_every   | 一定間隔ごとに変換する             | Enum.map_every 1..5, 3, &(&1*100)                      | [100, 2, 3, 400, 5] |
| each        | 反復して処理を実行する             | Enum.each 1..5, &(IO.puts &1)                          | :ok                 |
| map         | 変換する                           | Enum.map 1..5, &(&1*2)                                 | [2, 4, 6, 8, 10]    |
| min         | 最小値を取得する                   | Enum.min 1..5                                          | 1                   |
| max         | 最大値を取得する                   | Enum.max 1..5                                          | 5                   |
| filter      | 条件に一致する要素だけ取得する     | Enum.filter 1..5, &(&1 < 3)                            | [1, 2]              |
| reduce      | 畳み込む                           | Enum.reduce 1..5, fn(x, acc) -> x + acc end            | 15                  |
| sort        | ソートする                         | Enum.shuffle(5..1) &#124;> Enum.sort`                  | [1, 2, 3, 4, 5]     |
| uniq        | ユニークにする                     | 1..10 &#124;> Enum.map(&(rem &1, 3)) &#124;> Enum.uniq | [1, 2, 0]           |
| uniq_by     | 関数の結果でユニークにする         | 1..10 &#124;> Enum.uniq_by(&(rem &1, 3))               | [1, 2, 3]           |


ラムダ式
--------

`fn (el1, el2) -> el1 * el2 end`と`&(&1 * &2)`は等価
